# 认知思考工具 (Cognitive Thinking Tool)

## 🎯 工具定位

**统一的认知思考工具** - 将分散的思考工具统一为一个自适应工具，让系统整体架构更加纯粹且可以根据用户需求自适应调用以便更好地实现思考。

## 🏗️ 架构优势

### 1. 架构纯粹性
- **前**: 三个分散的思考工具 (`thinking-toolkit`, `sequential-thinking`, `think-plan`)
- **后**: 一个统一的认知思考工具，支持三种思考模式
- **收益**: 简化了工具调用接口，减少了认知负担

### 2. 自适应路由
- **智能识别**: 自动分析用户输入，判断使用探索性还是执行性思考模式
- **无缝切换**: 无需用户手动指定模式，工具自主决策
- **模式融合**: 支持显式指定模式，也支持自适应模式

### 3. 思考模式统一
- **探索性模式**: 适合问题诊断、分析、假设验证
- **执行性模式**: 适合任务规划、步骤执行、项目管理
- **自适应模式**: 自动选择最适合的思考模式

## 🚀 核心功能

### 1. 自适应思考路由
```javascript
// 自动识别思考模式
{
  "thought": "为什么系统性能下降？"  // → 自动选择探索性模式
}

{
  "thought": "需要实现用户登录功能",
  "plan": "1. 设计接口 2. 实现逻辑 3. 测试验证",
  "action": "开始设计登录接口"  // → 自动选择执行性模式
}
```

### 2. 顺序思考模式 (Sequential Thinking)
- **动态反思性思维**: 支持非线性思维、分支和修订
- **进度追踪**: 显示思考进度和完成状态
- **分支管理**: 支持多路径探索和比较
- **修订机制**: 可以修正之前的思考结论

### 3. 规划执行模式 (Think-Plan-Action)
- **三元结构**: 思考(Thought) → 计划(Plan) → 行动(Action)
- **步骤追踪**: 通过编号管理思考序列
- **会话隔离**: 支持多任务并行管理
- **执行导向**: 强制要求明确的下一步行动

## 📋 使用指南

### 基本用法

#### 自适应模式（推荐）
```javascript
// 工具自动判断使用哪种思考模式
{
  "thought": "分析用户流失的原因和解决方案"
}
```

#### 显式指定模式
```javascript
// 强制使用探索性模式
{
  "mode": "exploratory",
  "thought": "为什么数据库查询变慢了？",
  "nextThoughtNeeded": true
}

// 强制使用执行性模式
{
  "mode": "execution",
  "thought": "需要上线新版本",
  "plan": "1. 备份数据 2. 部署代码 3. 验证功能",
  "action": "执行备份脚本",
  "thoughtNumber": "TP-001"
}
```

### 高级用法

#### 分支思考
```javascript
{
  "mode": "exploratory",
  "thought": "考虑方案B的优缺点",
  "branchFromThought": 3,
  "branchId": "scheme-b-analysis"
}
```

#### 思考修订
```javascript
{
  "mode": "exploratory",
  "thought": "重新思考：内存泄漏可能是主要原因",
  "isRevision": true,
  "revisesThought": 5
}
```

#### 会话管理
```javascript
{
  "mode": "execution",
  "thought": "继续项目规划",
  "plan": "完善测试策略",
  "action": "编写集成测试",
  "thoughtNumber": "PLAN-004",
  "sessionId": "project-alpha"
}
```

## 🎯 场景识别

### 探索性场景（Exploratory）
**何时使用**: 需要分析、诊断、假设验证的问题

- ❓ 问题诊断: "为什么系统崩溃了？"
- 📊 数据分析: "销售数据下降的原因是什么？"
- 🔬 假设验证: "这个架构是否适合我们的需求？"
- 💡 创意探索: "有哪些创新的解决方案？"

**关键词识别**:
- 为什么、怎么、是什么、原因
- 分析、诊断、探索、发现
- 可能、或许、假设、如果...那么

### 执行性场景（Execution）
**何时使用**: 目标明确，需要具体执行步骤的任务

- ✅ 功能开发: "实现用户注册功能"
- 🚀 项目部署: "上线新版本到生产环境"
- 📝 任务执行: "完成季度报告"
- 🔧 系统迁移: "将数据库迁移到新服务器"

**关键词识别**:
- 实现、执行、完成、部署
- 步骤、计划、行动、任务
- 备份、测试、验证、迁移

## 📊 参数说明

### 通用参数
- `mode`: 思考模式 (`adaptive` | `exploratory` | `execution`)
- `sessionId`: 会话标识符（默认: "default"）

### 探索性模式参数
- `thought`: 当前思考内容（必需）
- `nextThoughtNeeded`: 是否需要继续思考（默认: true）
- `thoughtNumber`: 思考编号
- `totalThoughts`: 预计总步骤数（默认: 10）
- `isRevision`: 是否为修订（默认: false）
- `revisesThought`: 被修订的思考编号
- `branchFromThought`: 分支起始思考编号
- `branchId`: 分支标识符
- `needsMoreThoughts`: 是否需要更多思考（默认: false）

### 执行性模式参数
- `thought`: 思考内容（必需）
- `plan`: 规划方案（必需）
- `action`: 下一步行动（必需）
- `thoughtNumber`: 思考编号（必需）

## 💡 使用示例

### 示例1：问题诊断（自适应 → 探索性）
```javascript
// 输入
{
  "thought": "系统响应时间变慢，可能的原因是什么？"
}

// 输出
🧠 **顺序思考模式**
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

**思考 1**
系统响应时间变慢，可能的原因是什么？

**进度**: 1/10 (10%)

**下一步**: 继续思考...
```

### 示例2：项目规划（自适应 → 执行性）
```javascript
// 输入
{
  "thought": "需要重构用户认证模块",
  "plan": "1. 分析现有代码 2. 设计新架构 3. 分步重构 4. 测试验证",
  "action": "先分析现有认证代码的结构和问题",
  "thoughtNumber": "REFACTOR-001"
}

// 输出
📋 **思考规划模式**
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

**思考编号**: [REFACTOR-001]

🤔 **思考内容**:
需要重构用户认证模块

📋 **规划方案**:
1. 分析现有代码 2. 设计新架构 3. 分步重构 4. 测试验证

🎯 **下一步行动**:
先分析现有认证代码的结构和问题

⏰ **记录时间**: 2025-01-08 18:37:54
```

### 示例3：创意发散（分支思考）
```javascript
// 输入
{
  "mode": "exploratory",
  "thought": "探索使用微服务架构的可能性",
  "branchFromThought": 2,
  "branchId": "microservices-pros-cons"
}

// 输出
🧠 **顺序思考模式**
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

**思考 2**
探索使用微服务架构的可能性

**分支**:
  └─ 分支 microservices-pros-cons (来自思考 2)
```

## 🔧 技术实现

### 自适应路由算法
1. **关键词分析**: 检测输入中的关键词模式
2. **参数特征识别**: 分析提供的参数类型
3. **上下文推理**: 根据参数组合判断思考意图
4. **模式决策**: 选择最适合的思考模式

### 状态管理
- **顺序思考**: 使用 ThinkingState 类管理思考序列
- **规划执行**: 使用 ThinkPlanMemory 类管理规划记录
- **会话隔离**: 支持多会话并行思考

### 安全与隔离
- 在独立沙箱环境中运行
- 通过受限API访问系统资源
- 自动路径验证和权限控制

## 🎉 架构收益

### 1. 用户体验提升
- **简化调用**: 从多个工具 → 一个工具
- **智能路由**: 自动选择最适合的模式
- **无缝切换**: 无需关心底层实现细节

### 2. 系统架构优化
- **减少复杂度**: 统一了思考工具的接口
- **提高一致性**: 标准化的参数和输出格式
- **便于维护**: 集中管理思考相关的功能

### 3. 功能增强
- **自适应能力**: 根据上下文智能决策
- **模式融合**: 支持三种思考模式的无缝切换
- **状态保持**: 保持思考历史的连续性

## 📈 未来扩展

- **多模态思考**: 支持图表、思维导图等可视化思考
- **协作思考**: 支持多用户协同思考
- **学习优化**: 根据使用模式自动优化路由算法
- **集成扩展**: 与其他AI工具深度集成

---

**作者**: Sean (deepractice.ai)
**版本**: 1.0.0
**许可证**: MIT